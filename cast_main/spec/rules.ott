%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar typevar, X , Y ::= {{ repr-locally-nameless }} 

metavar termvar, x , y ::= {{ repr-locally-nameless }}

metavar label, l ::= {{ coq nat }} {{ tex \mathit{[[label]]} }}

metavar int, i ::= {{ coq nat }} {{ tex \mathit{[[int]]} }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR (LNgen portion)

grammar

typ, A {{ tex A }}, B {{ tex B }}, C {{ tex C }}, Char {{ tex \mathsf{Char} }}, Bool {{ tex \mathsf{Bool} }}, UKN {{ tex \,?\, }} :: 't_' ::= {{ com types }}
  | X              ::  :: var    {{ com type variable }}
  | Int            ::  :: int     {{ tex \mathsf{Int}  }} {{ com int }}
  | Top            ::  :: top     {{ tex \mathsf{Top}  }} {{ com top type }}
  | A -> B         ::  :: arrow   {{ com function type }}
  | mu X . A       ::  :: mu      (+ bind X in A +)
                                  {{ com recursive type }}
                                  {{ tex \mu [[X]].[[A]] }}
  | A [ X |-> B ]   :: M:: tsubst  {{ coq (open_typ_wrt_typ [[X A]][[B]]) }}
  | ( A )          :: S:: paren   {{ coq [[A]] }}


exp, e {{ tex e }}, v {{ tex v }}, u {{ tex u }}, v_f {{ tex v_f }} :: 'e_' ::= {{ com expressions }}
  | x              ::  :: var     {{ com variable }}
  | T              ::  :: top     {{ com top }}
  | i              ::  :: lit     {{ com lit }}
  | \ x : A . e
                   ::  :: abs     (+ bind x in e +)
                                  {{ com abstraction with argument annotation }}
                                  {{ tex \lambda [[x]][[:]][[A]].\,[[e]] }}
  | fix x : A . e  ::  :: fixpoint
                                  (+ bind x in e +)
                                  {{ com fixpoint }}
                                  {{ tex [[fix]]~[[x]][[:]][[A]].\,[[e]] }}
  | e1 e2          ::  :: app     {{ com applications }}
  | cast [ c ] e   :: :: cast    
  % | castup [ A ] e ::  :: castup  {{ com castup }}
  % | castdn [ A ] e ::  :: castdn  {{ com castdn }}
  | e1 [ x |-> e2 ] :: M:: subst   {{ coq (open_exp_wrt_exp [[x e1]][[e2]]) }}


  % | e1 [ x |~> e2 ] :: M:: subst_open   
  %     {{ coq (subst_bvar_exp 0  [[e2]] )) }}
  % | \ x : A . ( e1 [ ~> e2 ] ) :: M :: subst_abs_body
  %     % (+ bind x in e1, e2 +)
  %     {{ coq (e_abs [[A]] (close_exp_wrt_exp [[x]] (subst_exp [[e2]] [[x]] [[e1]] ))) }}
  | ( e )          :: S:: paren   {{ coq ([[e]]) }}
  | 1              :: M:: one     {{ tex 1 }} {{ coq (e_lit 1) }}
  | 2              :: M:: two     {{ tex 2 }} {{ coq (e_lit 2) }}
  | e1 + e2        :: M:: plus    {{ coq ([[e1]]+[[e2]]) }}
  % | True           :: M:: true    {{ tex \mathsf{True} }} {{ coq [[\x:Int.x:Int->Int]] }}
  % | False          :: M:: false   {{ tex \mathsf{False} }} {{ coq [[\x:Int.1:Int->Int]] }}
  | | e |          :: M:: erasexp {{ coq (erase_anno [[e]]) }}

mode, m {{ tex m }} :: 'm_' ::= {{ com modes }}
  | pos       ::   ::  pos    {{ com positive }} {{ tex \oplus }}
  | neg       ::   ::  neg    {{ com negative }} {{ tex \ominus }}


castop, c {{ tex c }} :: 'c_' ::= {{ com cast operators }}
  | id           ::   ::  id      {{ com id operator }} {{ tex \mathsf{id} }}
  | unfold [ A ] ::   ::  unfold  {{ com unfold operator }} {{ tex \downarrow_{[[A]]} }}
  | fold [ A ]   ::   ::  fold    {{ com castdn }} {{ tex \uparrow_{[[A]]} }}
  | c1 -> c2     ::   ::  arrow   {{ com arrow operator }} {{ tex [[c1]]\rightarrow[[c2]] }}
  | ~ c         ::  M  ::  reverse     {{ com reverse operator }} {{ tex \neg [[c]] }} {{coq (rev_cast [[c]]) }}


embed {{ coq

Fixpoint rev_cast (c : [[castop]]) : [[castop]] :=
  match c with
  | [[ id ]] => [[ id ]]
  | [[ unfold [A] ]] => [[ fold [A] ]]
  | [[ fold [A] ]] => [[ unfold [A] ]]
  | [[ c1 -> c2 ]] =>  c_arrow (rev_cast [[ c1 ]]) (rev_cast [[ c2 ]])
  end.

}}


substitutions
  single exp x   :: subst
  single typ X   :: typsubst


freevars
  exp x      :: termfv
  typ X      :: typefv


parsing
  t_arrow right t_arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR  (non LNgen portion)

grammar

ctx, G {{ tex \Gamma }} :: 'ctx_' ::=  {{ com term context }} {{ coq list ( atom * typ ) }}
  | []              ::  :: empty       {{ coq nil }}
                                       {{ tex \cdot }}
  | G , x : A       ::  :: cons        {{ coq (cons ([[x]],[[A]]) [[G]]) }}
  | G1 , G2         :: M:: constwo     {{ coq ([[G2]] ++ [[G1]]) }}
  | G1 , x : A , G2 :: M:: constwo_mid {{ coq ([[G2]] ++ (cons ([[x]],[[A]]) [[G1]])) }}


tctx, D {{ tex \Delta }} :: 'tctx_' ::= {{ com type context }} {{ coq list ( atom * unit ) }}
  | []              ::  :: empty        {{ coq nil }}
                                        {{ tex \cdot }}
  | D , X           ::  :: cons         {{ coq (cons ([[X]],tt ) [[D]]) }}
  | D1 , D2         :: M:: constwo      {{ coq ([[D2]] ++ [[D1]]) }}
  | D1 , X , D2     :: M:: constwo_mid  {{ coq ([[D2]] ++ (cons ([[X]],tt ) [[D1]])) }}


terminals :: 'terminals_' ::=
  | ~>           ::  :: subst      {{ tex \mapsto }}
  | \\           ::  :: lambda2    {{ tex \lambda }}
  | ->           ::  :: arrow      {{ tex \rightarrow }}
  | -->          ::  :: red        {{ tex \hookrightarrow }}
  | |-           ::  :: turnstile  {{ tex \vdash }}
  | |=           ::  :: dash2      {{ tex \models }}
  | T            ::  :: t          {{ tex \top }}
  | :            ::  :: Typ        {{ tex : }}
  | in           ::  :: in         {{ tex \in }}
  | ,            ::  :: break      {{ tex , }}
  | split        ::  :: split      {{ tex \mathsf{Split} }}
  | <*>          ::  :: disjointSpec    {{ tex ** }}
  | *            ::  :: disjoint        {{ tex * }}
  | *ax          ::  :: disjointAx      {{ tex *_{ax} }}
  | ~            ::  :: consistencySpec {{ tex \approx }}
  | ~~           ::  :: consistent {{ tex \approx\approx }}
  | ~~>          ::  :: TypeRed    {{ tex \hookrightarrow }}
  | |->          ::  :: tsubst     {{ tex \mapsto }}
  | <            ::  :: val2exprl  {{ tex \langle}}
  | >            ::  :: val2exprr  {{ tex \rangle}}
  | topl         ::  :: topl       {{ tex \rceil }}
  | topr         ::  :: topr       {{ tex \lceil }}
  | fix          ::  :: fixpoint   {{ tex \mathsf{fix} }}
  | Forall       ::  :: forall     {{ tex \forall }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | not formula              :: M :: not
    {{ tex \neg [[formula]] }}
    {{ coq not ([[formula]]) }}
  | formula1 or formula2     :: M :: or
    {{ tex [[formula1]]~\lor~[[formula2]] }}
    {{ coq ([[formula1]] \/ [[formula2]]) }}
  | ( formula )              :: M :: brackets
    {{ tex ([[formula]]\!) }}
    {{ coq [[formula]] }}
  | uniq G                   ::   :: uniqG
    {{ coq uniq [[G]] }}
    {{ tex }}
  | uniq D                   ::   :: uniqD
    {{ coq uniq [[D]] }}
    {{ tex }}
  | x : A in G               ::   :: inG
    {{ coq binds [[x]][[A]][[G]] }}
  | x notin fv e             ::   :: fresh
    {{ coq [[x]] \notin fv[[e]] }}
  | x notin dom G            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[G]]) }}
    {{ tex [[x]] \notin [[G]] }}
  | X in dom D               ::   :: InDx
    {{ coq [[X]] `in` (dom [[D]]) }}
    {{ tex [[X]] \in [[D]] }}
  | X notin dom D               ::   :: notInDx
    {{ coq ~ [[X]] `notin` (dom [[D]]) }}
    {{ tex [[X]] \notin [[D]] }}
  | l1 <> l2                 ::   :: label
    {{ coq [[l1]] <> [[l2]] }}
    {{ tex [[l1]] \neq [[l2]] }}
  | A = B                    ::   :: type
    {{ coq [[A]] = [[B]] }}
    {{ tex [[A]] = [[B]] }}
  | e1 = e2                  ::   :: term
    {{ coq [[e1]] = [[e2]] }}
    {{ tex [[e1]] = [[e2]] }}
  | e1 --> i e2              :: M :: multistep
    {{ coq (star exp step)[[i]][[e1]][[e2]] }}
    {{ tex [[e1]]~[[-->]][[i]]~[[e2]] }}
  | A <: B                   ::   :: subNoCtx
    {{ tex [[A]] <: [[B]] }}
  | e1 --> * e2               ::   :: msarrow
    {{ tex [[e1]]~[[-->]]^*~[[e2]] }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Well Formed Type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
WellFormedType :: '' ::=

defn
D |- A ::   :: WFT :: 'WFT_'
{{ com Well Formed Type }}
by

------------- :: top
D |- Top


------------- :: int
D |- Int

X in dom D
------------- :: var
D |- X


D |- A
D |- B
------------- :: arrow
D |- A->B

D, X |- A
------------- :: rec
D |- mu X. A



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Well Formed Environment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
WellFormedTypeEnv :: '' ::=

defn
|- D ::   :: WFTyE :: 'WFTyE_'
{{ com Well Formed Type Environment }}
by

------------ :: empty
|- []


|- D
X notin dom D
------------ :: cons
|- D, X


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type Reduction and Typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Ordinary :: '' ::=

defn
ordinary A ::  :: ordinary :: 'Ord_'
{{ com Ordinary type }} {{ tex \textsf{ord } [[A]] }}
by



---------------------- :: int
ordinary Int


--------------------------------- :: top
ordinary Top


--------------------------------- :: var
ordinary X


--------------------------------- :: rec
ordinary (mu X. A)



defns
TypCast :: '' ::=

defn
D |- A ~~> B : c ::  :: TypCast :: 'TCast_'
{{ com Typing Reduction Rules }}
by

D |- A
----------------- :: id
D |- A ~~> A : id


D |- A1 ~~> A2 : c1
D |- B1 ~~> B2 : c2
----------------- :: arrow
D |- A1 -> B1 ~~> A2 -> B2 : c1 -> c2


D |- mu X. A
----------------- :: unfold
D |- mu X. A ~~> A [X |-> mu X. A] : unfold [ mu X. A ]


D |- mu X. A
----------------- :: fold
D |- A [X |-> mu X. A] ~~> mu X. A : fold [ mu X. A]




defns
WellFormedTermEnv :: '' ::=

defn
D |- G ::   :: WFTmE :: 'WFTmE_'
{{ com Well Formed Term Environment }}
by

------------ :: empty
D |- []


D |- G
D |- A
x notin dom G
------------ :: cons
D |- G, x : A


defns
Typing :: '' ::=

defn
D ; G |- e : A ::  :: Typing :: 'Typing_'
{{ com Typing rules }}
by


|- D
D |- G
----------------- :: int
D; G |- i : Int

|- D
D |- G
x : A in G
----::var
D; G |- x : A


D; G, x : A1 |- e : A2
----::abs
D; G |- \ x : A1 . e : A1 -> A2


D; G |- e1 : A1 -> A2
D; G |- e2 : A1
----::app
D; G |- e1 e2 : A2

D; G, x : A |- e : A
----::fix
D; G |- fix x : A . e : A

% D; G |- e : A
% D |- A ~~> B 
% ----::castdn
% D; G |- castdn [ A ] e : B


% need to change the castdown annotation to make the push rule work
% D; G |- e : A
% D |- A ~~> B 
% ----::castdn
% D; G |- castdn [ B ] e : B


% D; G |- e : B
% D |- A ~~> B
% ----::castup
% D; G |- castup [ A ] e : A


D; G |- e : A
D |- A ~~> B : c
----::cast
D; G |- cast [ c ] e : B





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Values :: '' ::=

defn
value e ::  :: value :: V_
{{ com Values }} {{ tex \textsf{value } [[e]] }}
by



---------------------- :: lit
value i


--------------------------------- :: abs
value (\x : A . e)


value e
---------------------- :: fold
value (cast [ fold [A] ] e)


% should be value, otherwise erasure will fail
value e
---------------------- :: arrow
value (cast [ c1 -> c2 ] e)




% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% defns
% CValues :: '' ::=

% defn
% cvalue m e ::  :: cvalue :: CV_
% {{ com CValues }} {{ tex \textsf{cvalue } [[m]] \  [[e]] }}
% by


defns
DualCast :: '' ::=
defn
c1 ~ c2 ::  :: DualCast :: DCast_
{{ com DualCast }} {{ tex  [[c1]] \sim  [[c2]] }}

by

---------------------- :: id
id ~ id


c1 ~ c1'
c2 ~ c2'
---------------------- :: arrow
c1 -> c2 ~ c1' -> c2'



---------------------- :: rec
unfold [A] ~ fold [A]




defns
Reduction :: '' ::=

defn
e --> e' ::  :: Reduction :: 'Red_'
{{ com Reduction rules }}
by


----------------- :: beta
(\ x : A . e) e' --> e [ x |-> e' ]

e1 --> e1'
----------------- :: appl
e1 e2 --> e1' e2

value v1
e2 --> e2'
----------------- :: appr
v1 e2 -->  v1 e2'


----------------- :: fix
fix x : A . e --> e [ x |-> fix x : A . e ]





----------------- :: cast_arr
(cast [ c1 -> c2 ] e1) e2 --> cast [c2] (e1 (cast [~ c1] e2))


% Wrong version
% cannot deal with castdn (castdn (castdn ... (\x. ...))), no corresponding syntax
% ----------------- :: castdn_arr
% (castdn [ A2 -> B2 ] (\x : A1 . e1)) e2 -->  castdn [B2]  (e1 [x |-> castup [A1] e2])


% ----------------- :: castup_arr
% (castup [ A2 -> B2 ] (\x : A1 . e1)) e2 -->  castup [B2]  (e1 [x |-> castdn [A1] e2])


% Old version
% ----------------- :: castdn_arr
% castdn [ A2 -> B2 ] (\x : A1 . e) -->  \\x: A2 . ( castdn [B2] e [x |-> castup [A1] x])
% ----------------- :: castup_arr
% castup [ A2 -> B2 ] (\x : A1 . e) -->  \\x: A2 . ( castup [B2] e [x |-> castdn [A1] x])



e --> e'
----------------- :: cast
cast [ c ] e --> cast [ c ] e'


c1 ~ c2
value v
----------------- :: castelim
cast [ c1 ] (cast [ c2 ] v) --> v


value v
----------------- :: castid
cast [ id ] v --> v